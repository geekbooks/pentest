/*
 *  network/examples/tcp-proxy.c
 * 
 *  Copyleft (C) 2015  Sun Dro (a.k.a 7th Ghost)
 *
 * Example source code of TCP Proxy.
 */

/* C-ს ჰედერები*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>
#include <errno.h>

/* Linux-ის ჰედერები */
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/ip.h>

#define PROXY_STACK_SIZE 409600
#define MAXMSG 1024

typedef struct {
    int cfd;
    int sfd;
    int nfd;
} ProxySocket;

void init_proxy_socket(ProxySocket *ps)
{
    ps->cfd = 0;
    ps->sfd = 0;
    ps->nfd = 0;
}

int create_client_socket(char *addr, int16_t port)
{
    int sock, ret;
    struct sockaddr_in name;

    sock = socket (AF_INET, SOCK_STREAM, 0);
    if (sock < 0)
    {
        perror("socket");
        exit(-1);
    }

    name.sin_family = AF_INET;
    name.sin_port = htons (port);
    name.sin_addr.s_addr = inet_addr(addr);

    ret = connect(sock, (struct sockaddr *) &name, sizeof(name));
    if (ret < 0)
    {
        perror("connect");
        close(sock);
        exit(-1);
    }

    return sock;
}

int create_server_socket(char *addr, uint16_t port)
{
    int sock, ret;
    struct sockaddr_in name;

    sock = socket (PF_INET, SOCK_STREAM, 0);
    if (sock < 0)
    {
        perror("socket");
        exit(-1);
    }

    name.sin_family = AF_INET;
    name.sin_port = htons (port);

    if (addr != NULL) name.sin_addr.s_addr = inet_addr(addr);
    else name.sin_addr.s_addr = htonl (INADDR_ANY);

    ret = bind(sock, (struct sockaddr *) &name, sizeof(name));
    if (ret < 0)
    {
        close(sock);
        perror("bind");
        exit(-1);
    }

    ret = listen(sock, 5);
    if (ret < 0) 
    {
        perror("listen");
        close(sock);
        exit(-1);
    }
    printf("[*] Listening on %s:%d\n", addr, port);

    return sock;
}

void hex_dump(unsigned char* data, int size)
{
    int i, j;

    printf("    =================[ HEXDUMP DATA ]=================\n");

    /* დავბეჭდოთ მთელი ბაფერი */
    for(i=0; i < size; i++)
    {
        if(i && i%16 == 0)
        {
            printf("         ");
            for(j = i-16; j < i; j++)
            {
                /* დავბეჭდოთ თუ რიცხვია */
                if(data[j] >= 32 && data[j] <= 128) 
                    printf("%c", (unsigned char)data[j]);
                else 
                    printf(".");
            }
            printf("\n");
        }
        
        /* დავბეჭდოთ hex მონაცემები */
        if(i%16 == 0) printf("   ");
        printf(" %02X", (unsigned int)data[i]);
        
        /* დავბეჭდოთ ბოლო სფეისები */
        if(i == size - 1)
        {
            /* ექსტრა სფეისები */
            for(j=0; j < 15-i%16; j++) printf("   ");
            printf("         ");
            
            /* დავბეჭდოთ მონაცემები */
            for(j = i-i%16; j <= i; j++)
            {
                if(data[j] >= 32 && data[j] <= 128) 
                    printf("%c", (unsigned char)data[j]);
                else 
                    printf(".");
            }
            printf("\n");
        }
    }
    printf("    ===================[ END DATA ]===================\n");

}

void* start_proxy_connection(void *arg) 
{
    int data_len;
    char buf[MAXMSG];
    unsigned short iph_len;
    struct iphdr *iph;
    ProxySocket *ps = (ProxySocket*)arg;

    /* წავიკითხოთ ინფორმაცია */
    data_len = read(ps->sfd, buf, sizeof(buf));
    if (data_len > 0)
    {
        /* დავდამპოთ პაკეტი */
        printf("[*] Received from client\n");
        iph = (struct iphdr *)buf;
        iph_len = iph->ihl * 4;
        hex_dump(buf, iph_len);

        /* გავაგზავნოთ პაკეტი დაშორებულ სერვერთან */
        send(ps->cfd, buf, strlen(buf), 0);
        printf("[*] Data sent to remote server\n\n");
    }

    /* წავიკითხოთ ინფორმაცია */
    data_len = read(ps->cfd, buf, sizeof(buf));
    if (data_len > 0)
    {
        /* დავდამპოთ პაკეტი */
        printf("[*] Received data from remote server\n");
        iph = (struct iphdr *)buf;
        iph_len = iph->ihl * 4;
        hex_dump(buf, iph_len);

        /* გავაგზავნოთ პაკეტი დაშორებულ სერვერთან */
        send(ps->sfd, buf, strlen(buf), 0);
        printf("[*] Data sent to client\n\n");
    }

    close(ps->sfd);
    close(ps->cfd);
}

int main(int argc, char *argv[]) 
{
    int clientfd, serverfd, newfd, status;
    static struct sockaddr_in peer;
    pthread_attr_t thread_attr;
    pthread_t proxy_thread;
    ProxySocket ps;
    socklen_t len;

    /* შევამოწმოთ ვალიდური არგუმენტები */
    if (argc < 5) 
    {
        printf("=====================================================================\n");
        printf("Usage: %s [localhost] [localport] [remotehost] [remoteport]\n", argv[0]);
        printf("Example: %s 127.0.0.1 9000 97.64.102.10 9000\n", argv[0]);
        printf("=====================================================================\n");
        exit(1);
    }

    /* შევქმნათ სერვერის სოკეტი */
    serverfd = create_server_socket(argv[1], atoi(argv[2]));

    /* თრედის ატრიბუტის ინიციალიზაცია */
    pthread_attr_init(&thread_attr);
    pthread_attr_setstacksize(&thread_attr, PROXY_STACK_SIZE);
    pthread_attr_setdetachstate(&thread_attr, PROXY_STACK_SIZE);

    /* სოკეტების სტრუქტურის ინიციალიზაცია */
    init_proxy_socket(&ps);

    /* შევქმნათ პროქსის მარყუჟი */
    while(1) 
    {
        len = sizeof(struct sockaddr);
        newfd = accept(serverfd, (struct sockaddr *) &peer, &len);
        if (newfd >= 0) 
        {
            /* შევქმნათ კლიენტის სოკეტი */
            clientfd = create_client_socket(argv[3], atoi(argv[4]));

            /* შევინახოთ სოკეტები სტრუქტურაში */
            ps.sfd = newfd;
            ps.cfd = clientfd;

            /* შევქმნათ პროქსის თრედი */
            status = pthread_create(&proxy_thread, &thread_attr, &start_proxy_connection, &ps);
            if (status) perror("Can not create proxy thread");
        }
        else perror("accept");
    }
}